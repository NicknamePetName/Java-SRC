# 第二章 基本数据类型与数组  
· 标识符：由字母、下画线、美元符号、数字组成。`第一个字符不能是数字字符`  
· byte: 1个字节，-128~127 可以把int型常量赋值给byte.因为补码，所以负数多一  
· long型：十进制(108L)、八进制(071232L)、十六进制(0x3ABCL)  
· float:精度8  
· double:精度16  
· java键盘输入 
```  
    Scanner scanner = new Scanner(System.in);  
        int x = scanner.nextInt();
        scanner.hasNextInt();  判断输入是否为整数
```
· 声明数组+分配空间
``` 
    float boy[];  float a[][];  
    char[] cat;   char[][]b;  
    boy = new float[2];  
    float boy[] = new float[2];  声明和分配空间同时完成  
    float a[][] = new float[3][2];  
    float boy[] = { 21.3f,23.89f,2.0f,23f,778.98f};
```
# 第三章 运算符、表达式、语句
· instanceof 运算符，判断对象是否是类的,true,false
``` 
    String s=new String("abc");  
    if(s instanceof  String)  
        System.out.println("s是String对象");  
```
# 第四章 类与对象
· boolean:默认值false  
· char:默认是'\\0'(空字符)  
· float/double:默认值 0.0  
· 对于"引用型"变量(数组、对象)：默认值null  
· 局部变量没有默认值，需要赋值，否则编译错误  
```
    class  A    {  
        int a=12; //声明成员变量并指定初始值12  
        int b; //声明成员变量默认初始值0  
        b=12;  //错误，这是语句  只能在方法中赋值
    }
```
· 可变参数,这些参数的类型必须相同  
`   public void f(double item, int … x)`  
`   public void g(int … x)`  
```  
    public int getSum(int... x) {//x可变参数的参数代表  可传数组为参数
        int sum=0,sun=0;  
        for(int i=0;i<x.length;i++) {  
            sum=sum+x[i];  
        }  
        for(int parm:x) {  
            sun +=x[i];  
        }  
        return sum;  
    }  
```
· 类变量也称static 变量、静态变量  
· 类变量与实例变量的区别  P86  
1. 不同对象的实例变量互不相同    
2. *所有对象共享类变量*    
3. 通过类名直接访问类变量    类的字节码加载到内存，该类没有创建对象，实例变量不分配内存，类变量分配内存(共享内存)，程序退出(结束)后才释放内存。
```
    class Dog {
        float x;            //实例变量
        static int y;       //类变量 
        
    }
```
· 实例方法(不加static),类方法加(static)  
· 实例方法和类方法的区别  P88  
1. 对象调用实例方法  创建对象才有(实例)方法入口地址，且被所有对象共享，所有对象都不存在时，(实例)方法入口才消失  
   实例方法可以操作：实例变量和类变量，可以调用：实例方法和类方法(不包括构造方法)  *不能通过类名调用*
2. 类名调用类方法  类加载到内存就分配了入口地址，可以被类创建的任何对象调用、执行，还可以直接通过*类名*调用，程序退出入口消失
3. 设计类方法的原则  不需要操作类中的任何实例变量和方法   即可  

· 方法重载与多态  
1. 两种多态：重载(Overload) 重写(Override),重写是与继承有关的多态  
2. 方法重载的意思是：一个类中可以有多个方法具有相同的名字，但这些方法的参数的个数不同，或者是参数的类型不同  
3. 构造方法也可以重载，但构造方法不参与和非构造方法之间的重载比较  

· 方法重载的语法规则
1. 参数的个数不同
2. 参数的个数相同，但参数列表中对应的某个参数的类型不同  
3. 注：方法的返回类型和参数的名字不参与比较

· 避免重载出现歧义  static void Dog(int a,double b);   static void Dog(double a,int b);   Dog(10,10)则出错  
· this关键字 this可以出现在实例方法和构造方法中，不可以出现在类方法中  
· 引入类库中的类  (import 语句)  
1. java.long 包含所有的基本语言类(见第8、12章)
2. javax.swing 包含抽象窗口工具集中的图形、文本、窗口GUI类(见第9章)
3. java.io 包含所有的输入、输出类(见第10章)
4. java.util 包含实用类(见第8章)
5. java.sql 包含操作数据库的类(见第11章)
6. java.net 包含所有实现网络功能的类(见第13章)
7. 如果要引入一个包中的所有类，则可以用通配符"\*"来代.2666666666666666y替1 111111如：import java.util.\*  

## 访问权限
`静态————>类名`   `非静态————>对象`  
` 类方法:只能访问——>类变量        实例方法:可以访问———>实例变量、类变量（所有成员变量） `  
`访问权限： public———>protected————>友好(默认)类————>private`  
`不能用protected,private修饰类（但可以修饰内部类）`  

· 私有变量和私有方法(private)  
1. 私有变量和私有方法  `不能`  在任何类中通过 `对象` 操纵和调用 自己的变量和方法  
2. 私有类变量(private静态成员变量)，私有类方法(~)，`不能`  在任何类中通过 `类名` 操纵和调用 自己的类变量和类方法  

· 公有变量和公有方法(public)  
1. 公有变量和公有方法  `可以`  在任何类中通过 `对象` 操纵和调用 自己的变量和方法  
2. 公有类变量(private静态成员变量)，公有类方法(~)，`可以`  在任何类中通过 `类名` 操纵和调用 自己的类变量和类方法  

· 友好变量和友好方法(默认的，不用private、protected、publicxiushid)  
1. 友好变量和友好方法，在 `相同包` 中,所有类 `可以` 通过 `对象`操纵和调用 自己的变量和方法  
2. 友好类变量和友好类方法，在 `相同包` 中,所有类 `可以` 通过 `类名`操纵和调用 自己的类变量和类方法  

· 受保护的变量和方法(protected)  
1. 受保护的变量和方法，在 `相同包` 中,所有类 `可以` 通过 `对象`操纵和调用 自己的变量和方法  
2. 受保护的类变量和类方法，在 `相同包` 中,所有类 `可以` 通过 `类名`操纵和调用 自己的类变量和类方法  

· public类和友好（默认）类
1. 在另一个类中使用友好类创建对象时要保证他们在同一个包中  
![访问权限级别](https://github.com/NicknamePetName/Photo/blob/main/java/java_konwphoto/%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BC%98%E5%85%88%E7%BA%A7.png?raw=true)

· character类实现了对char基本型数据的类包装  P104  
· var局部变量: 必须显示指定初值(不可以为null),方法的参数和返回类型不可以用var声明  
  var是保留类型名称，不是Java关键字，var可以用作变量和方法，但不能作为类或接口的名称  

· jar文件 P106  
· 文档生成器 javadoc.exe 可以制作源文件中类的组成结构的html文档  

# 第五章 子类与继承
· 在同一包中，子类不能继承private成员变量 和 private方法   
· 不在同一包中，子类不能继承private,友好(默认)成员变量和方法   
· protect (对象的调用须在同一包中)  继承的进一步说明  P127   
· 子类的构造方法创建了一对象时，子类本身和父类成员变量都分配了内存空间  
· 子类、父类不在一个包中，子类不继承父类的友好(默认)成员变量，子类从父类继承的方法可以操作未来继承的成员变量  
· 子类继承的方法只能操作父类的成员变量，不能操作子类新增的成员变量  

· **instancdof运算符**：对象<——左，右——>类，左边是右边的类或子类创建的对象时，则instancdof运算结果是true,反之则false  

`**成员变量的隐藏**：子类声明的成员变量与其继承的成员变量名相同  *特点如下*：`  
1. 子类对象以及子类自己定义的方法操作与父类同名的成员变量是指子类重新声明的这个成员变量  
2. 子类对象可以调用继承的方法操作被子类隐藏的成员变量  
· 注:子类继承的方法可以操作子类继承和隐藏的成员变量，不可以操作子类新声明的的成员变量。子类新定义的方法可以操作子类继承和子类新声明的哦哦成员变量，但无法操作子类隐藏的成员变量（需使用super关键字操作隐藏的成员变量）  

· 方法重写：子类重写方法的名字、参数个数、参数类型、返回值类型必须和父类相同  
· 方法重写可以操作继承的成员变量和方法，新声明的成员变量、调用新定义的其他方法，隐藏的成员变量和方法需要用super关键字   
· 父类的方法是Object类型，子类重写的方法类型是Integer类型  
· 重写父类的方法时，只能提高访问权限  

· super操作被隐藏的成员变量和方法  
· 子类的构造方法创建一个子类对象时，子类的构造方法总是先调用父类的某个构造方法，子类没有显示指明使用父类的那个构造方法，则调用不带参的  
· 子类不继承构造方法，所以子类需要用super(arge1)调用父类的构造方法，并且super是子类构造方法的头一个语句  
· 注：为避免编译出错，父类应定义一个无参构造方法  

· final关键字：final类不能被继承，final方法不允许继承，不允许隐藏，成员、局部变量被fianl修饰则变为常量，所以声明时必须指定该常量的值   

· 对象的上转型对象：实体是子类创建的  
1. 上转型对象不能访问子类新增的成员变量，不能调用子类新增的方法   
2. 上转型对象可以访问子类继承和隐藏的成员变量，亦可以调用子类继承和重写的方法(调用重写的方法等同于子类对象的调用)  
· 注：可以将上转型对象在强制转换为子类对象，这是具备子类的所有属性与功能  
· 注：子类重写了父类静态方法，则子类对象的上转型对象不能调用子类重写的静态方法，只能调用父类的静态方法  
![上转型对象](https://github.com/NicknamePetName/Photo/blob/main/java/java_konwphoto/%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%AF%B9%E8%B1%A1.png?raw=true)


· abstract方法：只允许声方法，不允许实现。不允许final和abstract同时修饰一个方法或类。不允许static,private修饰abstract方法  
· abstract类：abstract类中可以有abstract方法和非abstract方法。非abstract类中不可以有abstract方法  
· abstract类：不能用new创建对象，非抽象子类必须重写抽象父类的抽象方法   
· 一个abstract类是abstract类的子类，它可以重写父类的abstract方法，亦可以继承abstract类的方法  
· abstract类的对象做上转型对象：使用abstract类声明对象，不能用new创建对象，但该对象可以成为其子类的上转型对象，就可以调用子类重写的方法  
`对象可以赋值为null  (Test test = null;)`   
 

























